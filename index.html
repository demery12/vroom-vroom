<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vroom Vroom</title>
</head>
<body>
    <canvas id="ctx" width="500" height="500" style="border:1px solid #000000;"></canvas>
    <audio loop autoplay preload="metadata" style=" width:300px;">
        <source src="static/audio/vroom_vroom.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio><br />

    <script>
        const HEIGHT = 500;
        const WIDTH = 500;
        let LEVEL_SPEED = 3;
        const ctx = document.getElementById("ctx").getContext("2d");
        const canvas = document.getElementById("ctx");
        const FONT_SIZE = 20;
        const FONT_NAME = 'Arial';
        ctx.font =  FONT_SIZE + "px " + FONT_NAME;

        let GAME_STATE = "start";
        const DRAW_HITBOXES = false;

        class Scoreboard {
            constructor(params) {
                this.x = 5;
                this.y = 5;
                this.meter_width = 60;
                this.meter_height = 20;
                this.meter_value = 30;
                this.decay = 0.25;
                this.score = 0;
                this.passive_score_increase = 50;
                this.combo_multiplier = 1;
                this.score_ticks = 3;
                this.grace_period = 70;
                this.full_combo_countdown = 300;
                this.combo_countdown = this.full_combo_countdown;
                this.combo_max = 5;

            }
            draw(){
                if(this.meter_value <= 0){
                    console.log("Game Over!");
                    game_over();
                } else if (this.grace_period !== 0) {
                    this.grace_period -= 1;
                } else {
                    this.meter_value -= this.decay;
                }
                ctx.fillStyle = 'black';
                ctx.beginPath();
                ctx.rect(this.x, this.y, this.meter_width, this.meter_height);
                ctx.rect(this.x + this.meter_width, this.y, this.meter_width, this.meter_height);
                ctx.stroke();
                ctx.fillRect(this.x, this.y, (this.meter_value * (2 * this.meter_width)) / 100, this.meter_height);
                ctx.fillText("Combo: x"+this.combo_multiplier, this.x, this.y + this.meter_height + FONT_SIZE + 5)
                const score_length = (this.score + "").length;
                ctx.fillText(this.score+"", WIDTH - (10 + score_length * (FONT_SIZE/2)), this.y + FONT_SIZE)

                if(this.score_ticks === 0){
                    this.score += this.passive_score_increase * this.combo_multiplier;
                    this.score_ticks = 3
                } else {
                    this.score_ticks -= 1;
                }

                if(this.combo_countdown === 0){
                    this.combo_multiplier = Math.min(this.combo_multiplier + 1, this.combo_max);
                    this.combo_countdown = this.full_combo_countdown;
                } else if (this.meter_value >= 50) {
                    this.combo_countdown -= 1;
                } else {
                    this.combo_countdown = this.full_combo_countdown;
                    this.combo_multiplier = 1;
                }

            }

        }

        let scoreboard = new Scoreboard({});
        class Entity {
            constructor(params) {
                this.x = params.x || 0;
                this.y = params.y || 0;
                this.img = params.img || null;
                this.height = params.height || 0;
                this.width = params.width || 0;
                this.hitbox_x = params.hitbox_x || 0;
                this.hitbox_y = params.hitbox_y || 0;
                this.hitbox_height = params.hitbox_height || 0;
                this.hitbox_width = params.hitbox_width || 0;
            }
            colliding(entity){
                return this.hitbox_x <= (entity.hitbox_x + entity.hitbox_width) &&
                    this.hitbox_x + this.hitbox_width > entity.hitbox_x &&
                    this.hitbox_y <= (entity.hitbox_y + entity.hitbox_height) &&
                    this.hitbox_y + this.hitbox_height > entity.hitbox_y;
            }
            add_image(name, path, scale, callback){
                this.img[name] = new Image();
                this.img[name].onload = function() {
                    this.img[name].sHeight = this.img[name].height * scale;
                    this.img[name].sWidth = this.img[name].width * scale
                    callback();
                }.bind(this);
                this.img[name].src = path;
            }
            draw_hitbox(){
                ctx.fillStyle = 'rgba(215, 50, 50, 0.50)';
                ctx.fillRect(this.hitbox_x, this.hitbox_y, this.hitbox_width, this.hitbox_height);
            }
        }

        class Car extends Entity {
            constructor(params) {
                const CAR_SCALE = 0.04;

                params.img = {};

                super(params);

                this.add_image('forward_car','static/img/pink_car_forward.png', CAR_SCALE, function(){
                    this.x = WIDTH/2 - this.img['forward_car'].sWidth/2;
                    this.y = HEIGHT - (this.img['forward_car'].sHeight + 5);
                    this.height = this.img['forward_car'].sHeight;
                    this.width = this.img['forward_car'].sWidth;
                    this.hitbox_height = this.height;
                    this.hitbox_width = this.width;
                    this.hitbox_x = this.x;
                    this.hitbox_y = this.y;
                }.bind(this));
                this.add_image('left_car','static/img/pink_car_left.png', CAR_SCALE, function(){});
                this.add_image('right_car', 'static/img/pink_car_right.png', CAR_SCALE, function(){});

                this.x_speed = 0;
                this.y_speed = 0;
                this.max_x_speed = 5;
                this.max_y_speed = 7;
                this.car_orientation = 'forward_car';
                this.scoreboard = params.scoreboard;
            }
            draw(){
                if (this.x_speed === 0){
                    this.car_orientation = 'forward_car';
                } else if (this.x_speed > 0) {
                    this.car_orientation = 'right_car';
                  } else {
                  this.car_orientation = 'left_car';
                }
                this.detect_collision()
                ctx.drawImage(this.img[this.car_orientation], this.x, this.y, this.img[this.car_orientation].sWidth, this.img[this.car_orientation].sHeight);

                this.y += this.y_speed;
                if (this.y <= 0){
                    this.y = 2;
                } else if (this.y >= HEIGHT){
                    this.y = HEIGHT - this.height/2;
                }
                this.x += this.x_speed;
                if(this.x <= 0){
                    this.x = 2;
                }
                if(this.x >= WIDTH - this.width){
                    this.x = (WIDTH - this.width) - 2;
                }
                this.hitbox_x = this.x;
                this.hitbox_y = this.y;

            }
            detect_collision(){
                for(const collectible_id in Collectible.list){
                    const collectible = Collectible.list[collectible_id];
                    if (this.colliding(collectible)){
                        Collectible.flagged_for_deletion.push(collectible_id);
                        this.scoreboard.meter_value += 10;
                        this.scoreboard.score += 1000 * this.scoreboard.combo_multiplier;
                        if(this.scoreboard.meter_value > 100){
                            this.scoreboard.meter_value = 100;
                        }
                    }
                }
                for(const obstacle_id in Obstacle.list){
                    const obstacle = Obstacle.list[obstacle_id];
                    if (this.colliding(obstacle)){
                        console.log("Game Over!");
                        game_over();
                    }
                }
            }

        }


        class Obstacle extends Entity {
            constructor(params) {
                params.img = {};
                const TREE_SCALE = 1;
                super(params);
                this.add_image('tree1','static/img/trees/palmtree1.png', TREE_SCALE, function(){
                    this.height = this.img['tree1'].sHeight;
                    this.width = this.img['tree1'].sWidth;
                    this.hitbox_height = this.height / 3;
                    this.hitbox_width = this.width / 3;
                    this.y = 0 - this.height;
                    this.hitbox_y = (this.y + this.height) - this.hitbox_height - 2;
                    this.hitbox_x = (this.x + this.width/2) - (this.hitbox_width / 2) - 5; // this is a little 'fine tuned'
                }.bind(this));

                this.y_speed = LEVEL_SPEED;
                this.id = Math.random();
                Obstacle.list[this.id] = this;
            }
            draw(){
                ctx.drawImage(this.img.tree1, this.x, this.y, this.img.tree1.sWidth, this.img.tree1.sHeight);
                this.y += this.y_speed;
                this.hitbox_y = (this.y + this.height) - this.hitbox_height - 2;
            }
        }

        class Collectible extends Entity {
            constructor(params) {
                params.img = {};
                const PILL_SCALE = 0.2;
                super(params);
                this.add_image('pill', 'static/img/cropped_pill.png', PILL_SCALE, function(){
                    this.height = this.img['pill'].sHeight;
                    this.width = this.img['pill'].sWidth;
                    this.hitbox_height = this.height;
                    this.hitbox_width = this.width;
                    this.y = 0 - this.height;
                    this.hitbox_y = this.y;
                    this.hitbox_x = this.x;
                }.bind(this))
                this.y_speed = LEVEL_SPEED;
                this.id = Math.random();
                Collectible.list[this.id] = this;
            }
            draw(){
                ctx.drawImage(this.img.pill, this.x, this.y, this.img.pill.sWidth, this.img.pill.sHeight);
                this.y += this.y_speed;
                this.hitbox_y = this.y;
            }
        }

        Obstacle.list = {};
        Collectible.list = {}
        Collectible.flagged_for_deletion = [];
        let car = new Car({scoreboard: scoreboard})

        class Background{
            constructor(params) {
                const TILE_SCALE = 1;
                this.img = {};
                this.background = [];
                this.add_image('sand1', 'static/img/background/sand1.png', TILE_SCALE, function(){});
                this.add_image('sand2', 'static/img/background/sand2.png', TILE_SCALE, function(){});
                this.add_image('sand3', 'static/img/background/sand3.png', TILE_SCALE, function(){});
                this.add_image('sand4', 'static/img/background/sand4.png', TILE_SCALE, function(){
                    this.tiles_needed_for_width = WIDTH / (this.img['sand1'].width) + 2;
                    this.tiles_needed_for_height = HEIGHT / (this.img['sand1'].height) + 2;

                    for(let i=0; i <= this.tiles_needed_for_height; i++){
                        this.background.push(this.create_row(this.tiles_needed_for_width, (i * this.img['sand1'].height)));
                    }
                }.bind(this));





            }

            create_row(length, shift) {
                const row = [];
                row.row_shift = shift;
                for(let j=0; j <= length; j++){
                    const r = Math.random();
                    if(r <= 0.7) {
                        row.push(1);
                    } else if (r <= 0.95) {
                        row.push(4);
                    } else {
                        row.push(3);
                    }
                }
                return row;
            }

            add_image(name, path, scale, callback){
                this.img[name] = new Image();
                this.img[name].onload = function() {
                    this.img[name].sHeight = this.img[name].height * scale;
                    this.img[name].sWidth = this.img[name].width * scale
                    callback();
                }.bind(this);
                this.img[name].src = path;
            }

            draw(){
                let y_delta = this.img.sand1.height;
                let y_shift = 0 - y_delta;
                const int_to_tile = {1:'sand1', 2:'sand2', 3:'sand3', 4:'sand4'};
                let delete_flag = false;
                for(const row of this.background){
                    let x_delta = this.img.sand2.width;
                    let x_shift = 0 - x_delta;
                    for(const tile_int of row){
                        const img = this.img[int_to_tile[tile_int]];
                        ctx.drawImage(img, x_shift, row.row_shift, img.sWidth, img.sHeight);
                        x_shift += x_delta;
                    }
                    y_shift += y_delta;
                    row.row_shift += LEVEL_SPEED;
                    if(row.row_shift > HEIGHT){
                        delete_flag = true;
                    }
                }

                if (delete_flag){
                    this.background.pop();
                    this.background.unshift(this.create_row(this.tiles_needed_for_width, this.background[0].row_shift - this.img['sand1'].sHeight));
                }
            }
        }
        let background = new Background({});

        function drawBackground(){
            background.draw();
        }

        function drawObstacles(){
            const r = Math.random();
            const draw_frequency = 0.01;
            if (r < draw_frequency){
                new Obstacle({x: r * WIDTH * (1/draw_frequency)})
            }
            const remove_list = [];
            for (let o_id in Obstacle.list){
                const o = Obstacle.list[o_id];
                o.draw();
                if(DRAW_HITBOXES){
                    o.draw_hitbox();
                }
                if (o.y > HEIGHT + 5){
                    remove_list.push(o.id);
                }
            }
            for(let o of remove_list){
                delete Obstacle.list[o];
            }
        }
        function drawCollectibles() {
            const r = Math.random();
            const draw_frequency = 0.05;
            if (r < draw_frequency){
                new Collectible({x: r * WIDTH * (1/draw_frequency)})
            }
            for (let c_id in Collectible.list){
                const c = Collectible.list[c_id];
                c.draw();
                if(DRAW_HITBOXES){
                    c.draw_hitbox();
                }
                if (c.y > HEIGHT + 5){
                    Collectible.flagged_for_deletion.push(c.id);
                }
            }
            for(let c of Collectible.flagged_for_deletion){
                delete Collectible.list[c];
            }
        }

        function drawPlayer(){
            car.draw()
            if(DRAW_HITBOXES){
                car.draw_hitbox();
            }
        }

        function drawHud(){
            scoreboard.draw();
        }

        function game_over(){
            GAME_STATE = "game_over"
        }

        function draw_game_over(){
            const end_text = "Game Over!"
            ctx.fillText(end_text, WIDTH/2 - (end_text.length * (FONT_SIZE/2)) / 2, HEIGHT/2 - FONT_SIZE/2)
        }

        function draw_start_screen(){
            const start_button = {height: 40, width: 100};
            // ctx.fillStyle = 'green';
            // ctx.fillRect(WIDTH/2 - start_button.width/2, HEIGHT/2 - start_button.height/2, start_button.width, start_button.height);
            ctx.fillStyle = 'black';
            const start_text = "Click anywhere to start";
            ctx.fillText(start_text, WIDTH/2 - ctx.measureText(start_text).width/2, HEIGHT/2 - ctx.measureText('M').width/2);
        }

        draw_start_screen();

        // update loop
        function game_loop() {
            console.log("running game loop");
            let loop = setInterval(function(){
                if(GAME_STATE === "game_over"){
                    draw_game_over();
                    clearInterval(loop);

                } else if (GAME_STATE === "play"){
                    ctx.clearRect(0,0, WIDTH, HEIGHT);
                    drawBackground();
                    drawCollectibles();
                    drawPlayer();
                    drawObstacles();
                    drawHud();
                } else if (GAME_STATE === "start"){
                    draw_start_screen();
                }

            }, 20);
        }

        document.onkeydown = function (event) {
            if (event.code === 'KeyD') //d
                car.x_speed = car.max_x_speed;
            else if (event.code === 'KeyS') //s
                car.y_speed = car.max_y_speed
            else if (event.code === 'KeyA') //a
                car.x_speed = -car.max_x_speed;
            else if (event.code === 'KeyW') //w
                car.y_speed = -car.max_y_speed
        }

        document.onkeyup = function (event) {
            if (event.code === 'KeyD') //d
                car.x_speed = 0;
            else if (event.code === 'KeyS') //s
                car.y_speed = 0;
            else if (event.code === 'KeyA') //a
                car.x_speed = 0;
            else if (event.code === 'KeyW') //w
                car.y_speed = 0;
        }

        canvas.onclick = function(event){
            if(GAME_STATE === 'start'){
                console.log("clicked start")
                GAME_STATE = 'play';
                game_loop();
            } else if (GAME_STATE === 'game_over'){
                console.log("clicked restart");
                GAME_STATE = 'play';
                const init_pack = initialize_game();
                scoreboard = init_pack['scoreboard'];
                car = init_pack['car'];
                background = init_pack['background'];
                game_loop();
            }
        }

        function initialize_game(){
            const object_pack = {}
            const scoreboard = new Scoreboard({});
            object_pack['scoreboard'] = scoreboard;
            object_pack['car'] = new Car({scoreboard: scoreboard})
            object_pack['background'] = new Background({});
            Obstacle.list = {};
            Collectible.list = {};
            return object_pack
        }

    </script>
</body>
</html>