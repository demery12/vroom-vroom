<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Vroom Vroom</title>
</head>
<body>
    <canvas id="ctx" width="500" height="500" style="border:1px solid #000000;"></canvas>
    <audio loop preload="metadata" style=" width:300px;">
        <source src="static/audio/vroom_vroom.mp3" type="audio/mpeg">
        Your browser does not support the audio element.
    </audio><br />
    <script>
        const HEIGHT = 500;
        const WIDTH = 500;
        let LEVEL_SPEED = 10;
        const ctx = document.getElementById("ctx").getContext("2d");
        ctx.font = "30px Arial";

        class Entity {
            constructor(params) {
                this.x = params.x || 0;
                this.y = params.y || 0;
                this.img = params.img || null;
                this.height = params.height;
                this.width = params.width;
            }
            colliding(entity){
                return this.x <= (entity.x + entity.width) &&
                    this.x + this.width > entity.x &&
                    this.y <= (entity.y + entity.height) &&
                    this.y + this.height > entity.y;
            }
        }

        class Car extends Entity {
            constructor(params) {
                const car_img = {};
                const CAR_SCALE = 0.04;
                car_img.forward_car = new Image();
                car_img.forward_car.src = 'static/img/pink_car_forward.png';
                car_img.forward_car.sHeight = car_img.forward_car.height * CAR_SCALE;
                car_img.forward_car.sWidth = car_img.forward_car.width * CAR_SCALE;

                car_img.left_car = new Image();
                car_img.left_car.src = 'static/img/pink_car_left.png';
                car_img.left_car.sHeight = car_img.left_car.height * CAR_SCALE;
                car_img.left_car.sWidth = car_img.left_car.width * CAR_SCALE;

                car_img.right_car = new Image();
                car_img.right_car.src = 'static/img/pink_car_right.png';
                car_img.right_car.sHeight = car_img.right_car.height * CAR_SCALE;
                car_img.right_car.sWidth = car_img.right_car.width * CAR_SCALE;
                params.img = car_img

                params.x = WIDTH/2 - car_img.forward_car.sWidth/2;
                params.y = HEIGHT - (car_img.forward_car.sHeight + 5);
                params.height = car_img.forward_car.sHeight;
                params.width = car_img.forward_car.sWidth;

                super(params);

                this.x_speed = 0;
                this.y_speed = 0;
                this.max_x_speed = 5;
                this.max_y_speed = 7;
                this.car_orientation = 'forward_car';
            }
            draw(){
                if (this.x_speed === 0){
                    this.car_orientation = 'forward_car';
                } else if (this.x_speed > 0) {
                    this.car_orientation = 'right_car';
                } else {
                    this.car_orientation = 'left_car';
                }
                this.detect_collision()
                ctx.drawImage(this.img[this.car_orientation], this.x, this.y, this.img[this.car_orientation].sWidth, this.img[this.car_orientation].sHeight);
                this.y += this.y_speed;
                this.x += this.x_speed;
            }
            detect_collision(){
                for(const collectible_id in Collectible.list){
                    const collectible = Collectible.list[collectible_id];
                    if (this.colliding(collectible)){
                        Collectible.flagged_for_deletion.push(collectible_id);
                    }
                }
                for(const obstacle_id in Obstacle.list){
                    const obstacle = Obstacle.list[obstacle_id];
                    if (this.colliding(obstacle)){
                        console.log("Game Over!")
                    }
                }
            }

        }


        class Obstacle extends Entity {
            constructor(params) {
                params.height = params.img.tree1.sHeight;
                params.width = params.img.tree1.sWidth;

                super(params);
                this.y_speed = LEVEL_SPEED;
                this.id = Math.random();
                Obstacle.list[this.id] = this;
            }
            draw(){
                ctx.drawImage(this.img.tree1, this.x, this.y, this.img.tree1.sWidth, this.img.tree1.sHeight);
                this.y += this.y_speed;
            }
        }

        class Collectible extends Entity {
            constructor(params) {
                params.height = params.img.pill.sHeight;
                params.width = params.img.pill.sWidth;

                super(params);
                this.y_speed = LEVEL_SPEED;
                this.id = Math.random();
                Collectible.list[this.id] = this;
            }
            draw(){
                ctx.drawImage(this.img.pill, this.x, this.y, this.img.pill.sWidth, this.img.pill.sHeight);
                this.y += this.y_speed;
            }
        }

        Obstacle.list = {};
        Collectible.list = {}
        Collectible.flagged_for_deletion = [];

        const obstacle_img = {};
        obstacle_img.tree1 = new Image();
        obstacle_img.tree1.src = 'static/img/trees/palmtree1.png';
        obstacle_img.tree1.sHeight = obstacle_img.tree1.height;
        obstacle_img.tree1.sWidth = obstacle_img.tree1.width;

        obstacle_img.dancing_tree1 = new Image();
        obstacle_img.dancing_tree1.src = 'static/img/trees/dancing_palmtree1.gif';
        obstacle_img.dancing_tree1.sHeight = 0.1;
        obstacle_img.dancing_tree1.sWidth = 0.1;

        const pill_img = {};
        pill_img.pill = new Image();
        pill_img.pill.src = 'static/img/pill.png';
        pill_img.pill.sHeight = pill_img.pill.height * 0.2;
        pill_img.pill.sWidth = pill_img.pill.width * 0.2;

        const car = new Car({})

        class Background{
            constructor(params) {
                const background_imgs = {};
                background_imgs.sand1 = new Image();
                background_imgs.sand1.src = 'static/img/background/sand1.png';
                background_imgs.sand1.sHeight = background_imgs.sand1.height;
                background_imgs.sand1.sWidth = background_imgs.sand1.width;

                background_imgs.sand2 = new Image();
                background_imgs.sand2.src = 'static/img/background/sand2.png';
                background_imgs.sand2.sHeight = background_imgs.sand2.height;
                background_imgs.sand2.sWidth = background_imgs.sand2.width;

                background_imgs.sand3 = new Image();
                background_imgs.sand3.src = 'static/img/background/sand3.png';
                background_imgs.sand3.sHeight = background_imgs.sand3.height;
                background_imgs.sand3.sWidth = background_imgs.sand3.width;

                background_imgs.sand4 = new Image();
                background_imgs.sand4.src = 'static/img/background/sand4.png';
                background_imgs.sand4.sHeight = background_imgs.sand4.height;
                background_imgs.sand4.sWidth = background_imgs.sand4.width;

                this.img = background_imgs;
                this.background = [];

                this.tiles_needed_for_width = WIDTH / (this.img.sand1.width + 1) + 2;
                this.tiles_needed_for_height = HEIGHT / (this.img.sand1.height + 1) + 2;

                for(let i=0; i <= this.tiles_needed_for_height; i++) {
                    this.background.push(this.create_row(this.tiles_needed_for_width));
                }
            }

            create_row(length) {
                const row = [];
                for(let j=0; j <= length; j++){
                    const r = Math.random();
                    if(r <= 0.7) {
                        row.push(1);
                    } else if (r <= 0.95) {
                        row.push(4);
                    } else {
                        row.push(3);
                    }
                }
                return row;
            }

            draw(){
                let y_delta = this.img.sand1.height;
                let y_shift = 0 - y_delta;
                const int_to_tile = {1:'sand1', 2:'sand2', 3:'sand3', 4:'sand4'};
                for(const row of this.background){
                    let x_delta = this.img.sand2.width;
                    let x_shift = 0 - x_delta;

                    for(const tile_int of row){
                        const img = this.img[int_to_tile[tile_int]];
                        ctx.drawImage(img, x_shift, y_shift, img.sWidth, img.sHeight);
                        x_shift += x_delta;
                    }
                    y_shift += y_delta;
                }
                this.background.pop();
                this.background.unshift(this.create_row(this.tiles_needed_for_width));
            }
        }
        const background = new Background({});
        function drawBackground(){
            background.draw();
        }

        function drawObstacles(){
            const r = Math.random();
            const draw_frequency = 0.1;
            if (r < draw_frequency){
                new Obstacle({x: r * WIDTH * (1/draw_frequency), y: 0 - obstacle_img.tree1.sHeight, img:obstacle_img})
            }
            const remove_list = [];
            for (let o_id in Obstacle.list){
                const o = Obstacle.list[o_id];
                o.draw();
                if (o.y > HEIGHT + 5){
                    remove_list.push(o.id);
                }
            }
            for(let o of remove_list){
                delete Obstacle.list[o];
            }
        }
        function drawCollectibles() {
            const r = Math.random();
            const draw_frequency = 0.05;
            if (r < draw_frequency){
                new Collectible({x: r * WIDTH * (1/draw_frequency), y: 0 - pill_img.pill.sHeight, img:pill_img})
            }
            for (let c_id in Collectible.list){
                const c = Collectible.list[c_id];
                c.draw();
                if (c.y > HEIGHT + 5){
                    Collectible.flagged_for_deletion.push(c.id);
                }
            }
            for(let c of Collectible.flagged_for_deletion){
                delete Collectible.list[c];
            }
        }

        function drawPlayer(){
            car.draw()
        }

        // update loop
        setInterval(function(){
            ctx.clearRect(0,0,500,500);
            drawBackground();
            drawObstacles();
            drawCollectibles();
            drawPlayer();

        }, 40)

        document.onkeydown = function (event) {
            if (event.code === 'KeyD') //d
                car.x_speed = car.max_x_speed;
            else if (event.code === 'KeyS') //s
                car.y_speed = car.max_y_speed
            else if (event.code === 'KeyA') //a
                car.x_speed = -car.max_x_speed;
            else if (event.code === 'KeyW') //w
                car.y_speed = -car.max_y_speed
        }

        document.onkeyup = function (event) {
            if (event.code === 'KeyD') //d
                car.x_speed = 0;
            else if (event.code === 'KeyS') //s
                car.y_speed = 0;
            else if (event.code === 'KeyA') //a
                car.x_speed = 0;
            else if (event.code === 'KeyW') //w
                car.y_speed = 0;
        }

    </script>
</body>
</html>